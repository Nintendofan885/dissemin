# Generated by Django 2.2.7 on 2019-12-10 10:55

import haystack

from django.db import migrations

from backend.pubtype_translations import CITEPROC_PUBTYPE_TRANSLATION
from papers.baremodels import PAPER_TYPE_CHOICES
from papers.models import OaiSource
from papers.models import OaiRecord
from papers.models import Paper

def update_crossref_pubtypes(apps, schema_editor):
    """
    This data migrations goes through all OaiRecords with source CrossRef and invalid publication type.
    It adjusts the publication type in the OaiRecord and the corresponding paper and updates the index.
    We do not use the most sober way with using apps given to this function.
    But since we do not alter DB this fine.
    The step is necessary, since updating the index requires a full object, not just the DB representation.
    """
    # Only source CrossRef
    c = OaiSource.objects.get(identifier='crossref')
    # Our valid publication types as list
    valid_pubtypes = [key for (key, value) in PAPER_TYPE_CHOICES]

    # As long as there are malicious entries, correct them in 1000er batches
    while OaiRecord.objects.filter(source=c).exclude(pubtype__in=valid_pubtypes).exists():
        for o in OaiRecord.objects.filter(source=c).exclude(pubtype__in=valid_pubtypes).select_related('about')[:1000]:
            new_pubtype = CITEPROC_PUBTYPE_TRANSLATION.get(o.pubtype, 'other')
            print('Change pubtype for OaiRecord {} from {} to {}'.format(o.id, o.pubtype, new_pubtype))
            o.pubtype = new_pubtype
            o.save()
            p = o.about
            p.doctype = o.pubtype
            p.save()
            # Objects in DB are no fine
            # Let's update the index
            using_backends = haystack.connection_router.for_write(instance=p)
            for using in using_backends:
                try:
                    index = haystack.connections[using].get_unified_index(
                                            ).get_index(Paper)
                    index.update_object(p, using=using)
                except haystack.exceptions.NotHandled as e:
                    print(e)
        print('Done with 1000 OaiRecords')


def reverse_pass(apps, schema_editor):
    pass


class Migration(migrations.Migration):

    # We don't wrap the migration into a single transaction, since:
    # 1. it's too big
    # 2. we need to update the index
    atomic = False

    dependencies = [
        ('papers', '0057_todolist'),
    ]

    operations = [
        migrations.RunPython(update_crossref_pubtypes, reverse_pass),
    ]
